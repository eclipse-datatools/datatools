/*******************************************************************************
 * Copyright (c) 2009 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Eclipse Public License 2.0
 * which is available at
 * https://www.eclipse.org/legal/epl-2.0/
 * 
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
package org.eclipse.datatools.sqltools.parsers.sql.query.test;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * This class provides sample SQL statements for use in unit testing.
 * This class is a singleton, so use the <code>getInstance</code> method to get
 * the single instance of this class.
 *  
 * @author bpayton
 */
public class StatementCache {

    /* The single instance of this class. */
    private static StatementCache gInstance = null;
    
    /**
     * Gets the single instance of this class.
     * @return
     */
    public static StatementCache getInstance() {
        if (gInstance == null) {
            gInstance = new StatementCache();
        }
        return gInstance;
    }
    
    /* Map of statement ID to statement source test */
    private Map<String, String> fSourceMap = null;
    /* Map of statement ID to expected generated statement text (template). 
     * Note: a statement that isn't expected to parse won't have a template. */
    private Map<String, String> fTemplateMap = null;
    
    /**
     * Constructs an instance of this class.  This is the default constructor.
     * This constructor is marked private so clients should use the <code>
     * getInstance</code> method to get the singleton instance.
     */
    private StatementCache() {
        fSourceMap = new LinkedHashMap<String, String>();
        fTemplateMap = new LinkedHashMap<String, String>();
        
        this.loadStatements();
    }
    
    /**
     * Adds the given test statement with the given category, group, and item IDs, source and template text
     * to the test statement repository. 
     * 
     * @param categoryID the test statement's major category ID, such as "SELECT"
     * @param groupID the test statement's group ID, such as "BASIC"
     * @param itemID the test statement's individual item ID, such as "01"
     * @param sourceTest the test statement source text
     * @param templateText the expected "getSQL" text from the statement model generated by the parser (null
     * if the parse is expected to fail)
     */
    public void addStatement(String categoryID, String groupID, String itemID, String sourceText, String templateText) {
        String stmtID = getStatementID(categoryID, groupID, itemID);
        fSourceMap.put(stmtID, sourceText);
        fTemplateMap.put(stmtID, templateText);
    }

    /**
     * Creates and returns a test script by combining all the test statements in the given category and group.
     * The statements are separated by the default statement terminator ":".
     * 
     * @param categoryID the script's category ID, such as "SELECT"
     * @param grouID the script's group ID, such as "BASIC"
     * @return the generated script
     */
    public String getScript(String categoryID, String groupID) {
        String script = getScript(categoryID, groupID, ";");
        
        return script;
    }
    
    /**
     * Creates and returns a test script by combining all the test statements in the given category and group, 
     * separated by the given statement terminator.
     * 
     * @param categoryID the script's category ID, such as "SELECT"
     * @param grouID the script's group ID, such as "BASIC"
     * @param stmtTerm the statement terminator string to use
     * @return the generated script
     */
    public String getScript(String categoryID, String groupID, String stmtTerm) {
        StringBuffer script = new StringBuffer();
        
        List<String> stmtList = getStatementList(categoryID, groupID);
        for (String stmt : stmtList) {
            script.append(stmt);
            script.append("\n");
            script.append(stmtTerm);
            script.append("\n");
        }
        
        return script.toString();
    }
    
    /**
     * Creates and returns a test template script by combining all the template statements in the 
     * given category and group.  The statements are separated by the default statement terminator ":".
     * 
     * @param categoryID the script's category ID, such as "SELECT"
     * @param grouID the script's group ID, such as "BASIC"
     * @return the generated template script
     */
    public String getTemplateScript(String categoryID, String groupID) {
        String script = getTemplateScript(categoryID, groupID, ";");
        
        return script;
    }

    /**
     * Creates and returns a test template script by combining all the template statements in the 
     * given category and group, separated by the given statement terminator.
     * 
     * @param categoryID the script's category ID, such as "SELECT"
     * @param grouID the script's group ID, such as "BASIC"
     * @param stmtTerm the statement terminator string to use
     * @return the generated template script
     */
    public String getTemplateScript(String categoryID, String groupID, String stmtTerm) {
        StringBuffer script = new StringBuffer();
        
        List<String> stmtList = getTemplateStatementList(categoryID, groupID);
        for (String stmt : stmtList) {
            script.append(stmt);
            script.append("\n");
            script.append(stmtTerm);
            script.append("\n");
        }
        
        return script.toString();
    }

    
    /**
     * Gets the test statement source text with the given identifiers.
     * 
     * @param categoryID the statement's category ID
     * @param groupID the statement's group ID
     * @param itemID the statement's item ID
     * @return the identified statement, or null if not found 
     */
    public String getStatement(String categoryID, String groupID, String itemID) {
        String stmtText = null;
        
        String stmtID = getStatementID(categoryID, groupID, itemID);
        stmtText = (String) fSourceMap.get(stmtID);
        
        return stmtText;
    }

    /**
     * Gets the template (getSQL) test statement text with the given identifiers.
     * 
     * @param categoryID the statement's category ID
     * @param groupID the statement's group ID
     * @param itemID the statement's item ID
     * @return the identified statement, or null if not found  
     */
    public String getTemplateStatement(String categoryID, String groupID, String itemID) {
        String templateText = null;
        
        String stmtID = getStatementID(categoryID, groupID, itemID);
        templateText = (String) fTemplateMap.get(stmtID);
        
        return templateText;
    }
    
    /**
     * Gets a list of the test statements in the given category and group.
     * If the group is null or the empty string, then all groups in the category
     * are returned. If the category is null or the empty string, then all
     * statements are returned.
     * 
     * @param categoryID the category ID of the desired statements
     * @return the list of test statements
     */
    public List<String> getStatementList(String categoryID, String groupID) {
        List<String> stmtList = new ArrayList<String>();
        
        String stmtIDprefix = getStatementID(categoryID, groupID, "");        
        String stmtID = "";
        String stmtText = "";
        
        for (Map.Entry<String, String> mapEntry : fSourceMap.entrySet() ) {
            stmtID = mapEntry.getKey();
            if (stmtID.startsWith(stmtIDprefix)) {
                stmtText = mapEntry.getValue();
                stmtList.add(stmtText);
            }
        }
        
        return stmtList;
    }

    /**
     * Gets a list of the test template statements in the given category and group.
     * If the group is null or the empty string, then all groups in the category
     * are returned. If the category is null or the empty string, then all
     * statements are returned.
     * 
     * @param categoryID the category ID of the desired statements
     * @return the list of test statements
     */
    public List<String> getTemplateStatementList(String categoryID, String groupID) {
        List<String> stmtList = new ArrayList<String>();
        
        String stmtIDprefix = getStatementID(categoryID, groupID, "");        
        String stmtID = "";
        String stmtText = "";
        
        for (Map.Entry<String, String> mapEntry : fTemplateMap.entrySet() ) {
            stmtID = mapEntry.getKey();
            if (stmtID.startsWith(stmtIDprefix)) {
                stmtText = mapEntry.getValue();
                stmtList.add(stmtText);
            }
        }
        
        return stmtList;
    }

    
    /**
     * Loads the initial set of test statements into the statement
     * repository.
     */
    private void loadStatements() {
 //       addStatement("s_01", "SELECT LASTNAME, FIRSTNME FROM EMPLOYEE");
 
        String catID = "";
        String groupID = "";
        String itemID = "";
        String sourceText = "";
        String templateText = "";
        
        /* SELECT statements */
        catID = "SELECT";
        groupID = "ORDER BY";
        
        itemID = "Type mix 1";
        sourceText = "select c1, c2 from table1 order by c2, 1";
        templateText = sourceText;
        addStatement(catID, groupID, itemID, sourceText, templateText);
        
        itemID = "Type mix 2";
        sourceText = "select c1, c2, c3 from table1 order by 1, c2, c4, 3, c1";
        templateText = sourceText;
        addStatement(catID, groupID, itemID, sourceText, templateText);
        
        itemID = "Summary 1";
        sourceText = "select c1, avg(c2) from table1 order by avg(c2), 1";
        templateText = sourceText;
        addStatement(catID, groupID, itemID, sourceText, templateText);
        
        /* MERGE statements */       
        catID = "MERGE";
        groupID = "BASIC";

        itemID = "sameSchema";
        sourceText = 
  "MERGE INTO mergetest USING mergetest2 ON (mergetest.col1 = mergetest2.col1) " +
  "WHEN MATCHED THEN UPDATE SET (col1, col2, col3) = (mergetest2.col1, mergetest2.col2, mergetest2.col3) " +
  "WHEN NOT MATCHED THEN INSERT (col1, col2, col3) VALUES (mergetest2.col1, mergetest2.col2, mergetest2.col3)";
        templateText = sourceText;
        addStatement(catID, groupID, itemID, sourceText, templateText);

        itemID = "differentTargetSchema";
        sourceText = 
  "MERGE INTO schema2.mergetest USING mergetest2 ON (schema2.mergetest.col1 = mergetest2.col1) " +
  "WHEN MATCHED THEN UPDATE SET (col1, col2, col3) = (mergetest2.col1, mergetest2.col2, mergetest2.col3) " +
  "WHEN NOT MATCHED THEN INSERT (col1, col2, col3) VALUES (mergetest2.col1, mergetest2.col2, mergetest2.col3)";
        templateText = sourceText;
        addStatement(catID, groupID, itemID, sourceText, templateText);
        
        itemID = "differentSourceSchema";
        sourceText = 
  "MERGE INTO mergetest USING schema2.mergetest2 ON (mergetest.col1 = schema2.mergetest2.col1) " +
  "WHEN MATCHED THEN UPDATE SET (col1, col2, col3) = (schema2.mergetest2.col1, schema2.mergetest2.col2, schema2.mergetest2.col3) " +
  "WHEN NOT MATCHED THEN INSERT (col1, col2, col3) VALUES (schema2.mergetest2.col1, schema2.mergetest2.col2, schema2.mergetest2.col3)";
        templateText = sourceText;
        addStatement(catID, groupID, itemID, sourceText, templateText);

        groupID = "OTHER";
        
        itemID = "querySource";
        sourceText =
  "MERGE INTO inventory AS in USING" + 
  "  (SELECT partno, description, count FROM shipment WHERE shipment.partno IS NOT NULL) AS sh" +
  "   ON (in.partno = sh.partno)" +
  " WHEN MATCHED THEN UPDATE SET" +
  "   description = sh.description, quantity = in.quantity + sh.count" +
  " WHEN NOT MATCHED THEN INSERT (partno, description, quantity)" +
  "    VALUES (sh.partno, sh.description, sh.count)";
        templateText = sourceText;
        addStatement(catID, groupID, itemID, sourceText, templateText);
 
        itemID = "tableFuncSource";
        sourceText = 
  "MERGE INTO employee AS t USING" +
  "   TABLE(VALUES(CAST (:empno AS CHAR(6)), CAST (:firstnme AS VARCHAR(12))," +
  "                CAST (:lastname AS VARCHAR(15)), CAST (:workdept AS CHAR(3))," + 
  "                CAST (:edlevel AS SMALLINT), CAST (:salary AS DECIMAL(9,2)) ))" +
  "      s(empno, firstnme, lastname, workdept, edlevel, salary)" +
  "   ON t.empno = s.empno" +
  " WHEN MATCHED THEN UPDATE SET salary = s.salary" +
  " WHEN NOT MATCHED THEN" +
  "    INSERT (empno, firstnme, lastname, workdept, edlevel, salary)" +
  "    VALUES (s.empno, s.firstnme, s.lastname, s.workdept, s.edlevel, s.salary)";
        templateText = sourceText;
        addStatement(catID, groupID, itemID, sourceText, templateText);
        
        /* CALL statements */
        catID = "CALL";
        groupID = "BASIC";
        
        itemID = "unqualifiedNoArgList";
        sourceText = "CALL GET_ANSWER";
        templateText = "CALL GET_ANSWER ()";
        addStatement(catID, groupID, itemID, sourceText, templateText);
        
        itemID = "unqualifiedEmptyArgList";
        sourceText = "CALL GET_ANSWER()";
        templateText = "CALL GET_ANSWER ()";
        addStatement(catID, groupID, itemID, sourceText, templateText);
        
        itemID = "unqualifiedOneArg";
        sourceText = "CALL GET_ANSWER ('Life, the Universe, and Everything')";
        templateText = sourceText;
        addStatement(catID, groupID, itemID, sourceText, templateText);
        
        itemID = "unqualifiedMultiArg";
        sourceText = "CALL GET_ANSWER ( 'Life', 'The Universe', 'and Everything' )";
        templateText = sourceText;
        addStatement(catID, groupID, itemID, sourceText, templateText);
        
        itemID = "unqualifiedParamMarkerArgs";
        sourceText = "CALL BAR(?, ?, ?)";
        templateText = sourceText;
        addStatement(catID, groupID, itemID, sourceText, templateText);

        itemID = "unqualifiedHostVarArgs";
        sourceText = "CALL BAR(:arg1, :arg2)";
        templateText = "CALL BAR(:ARG1, :ARG2)";
        addStatement(catID, groupID, itemID, sourceText, templateText);

        itemID = "qualifiedNoArgList";
        sourceText = "CALL FOO.BAR";
        templateText = "CALL FOO.BAR ()";
        addStatement(catID, groupID, itemID, sourceText, templateText);
        
        itemID = "qualifiedEmptyArgList";
        sourceText = "CALL FOO.BAR ( )";
        templateText = "CALL FOO.BAR()";
        addStatement(catID, groupID, itemID, sourceText, templateText);
        
        itemID = "lowerCaseWithMixedArgs";
        sourceText = "call foo .  bar ( 42, 'Fish', 12.34e2  )";
        templateText = "CALL FOO.BAR (42, 'Fish', 12.34e2)";
        addStatement(catID, groupID, itemID, sourceText, templateText);
        
        itemID = "delimitedNames";
        sourceText = "call \"foo bar \". \" Get Answer\"()";
        templateText = "CALL \"foo bar \".\" Get Answer\" ()"; 
        addStatement(catID, groupID, itemID, sourceText, templateText);
    }
    
    /**
     * Gets a statement ID based on the given category, group, and item IDs.
     * 
     * @param categoryID the category ID of a test statement
     * @param groupID the group ID of a test statement
     * @param itemID the item ID of a test statement
     * @return the statement ID
     */
    private String getStatementID(String categoryID, String groupID, String itemID) {
        String stmtID = categoryID + "_" + groupID + "_" + itemID;
        
        return stmtID;
    }
            
} // end class
