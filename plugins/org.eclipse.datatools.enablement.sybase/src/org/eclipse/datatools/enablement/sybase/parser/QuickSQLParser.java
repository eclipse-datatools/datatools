/* Generated By:JJTree&JavaCC: Do not edit this line. QuickSQLParser.java */
package org.eclipse.datatools.enablement.sybase.parser;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.HashMap;
import java.io.StringReader;
import org.eclipse.datatools.enablement.sybase.Activator;

public class QuickSQLParser extends AbstractQuickSQLParser/*@bgen(jjtree)*/implements QuickSQLParserTreeConstants, QuickSQLParserConstants {/*@bgen(jjtree)*/
  protected JJTQuickSQLParserState jjtree = new JJTQuickSQLParserState();private static QuickSQLParser _instance = new QuickSQLParser(new StringReader(""));
    private boolean _debug = false;

        private String _input = "";
    private boolean canUseDelimiter = false;
        private static final int[] STMT_START = new int[]{ALTER, BEGIN, BREAK, CHECKPOINT, CLOSE, COMMIT, CONNECT,
                CONTINUE, CREATE, DEALLOCATE, DECLARE, DELETE, DISK, DROP, DUMP, EXECUTE, EXEC,
                FETCH, GOTO, GRANT, IF, INSERT, KILL, LOAD, LOCK, ONLINE, OPEN, PREPARE, //MOUNT,
                PRINT, QUIESCE, RAISERROR, READTEXT, RECONFIGURE, REMOVE, REORG, RETURN, REVOKE,
                ROLLBACK, SAVE, SELECT, SET, SETUSER, SHUTDOWN, TRUNCATE, UPDATE, USE,//UNMOUNT, 
                WAITFOR, WHILE, WRITETEXT
                                 };

        public static final String[] STMT_START_STRING = new String[]{"ALTER","BEGIN","BREAK","CHECKPOINT","CLOSE","COMMIT","CONNECT",
        "CONTINUE","CREATE","DEALLOCATE","DECLARE","DELETE","DISK","DROP","DUMP","EXECUTE","EXEC",
        "FETCH","GOTO","GRANT","IF","INSERT","KILL","LOAD","LOCK","ONLINE","OPEN","PREPARE",
        "PRINT","QUIESCE","RAISERROR","READTEXT","RECONFIGURE","REMOVE","REORG","RETURN","REVOKE",
        "ROLLBACK","SAVE","SELECT","SET","SETUSER","SHUTDOWN","TRUNCATE","UPDATE","USE",
        "WAITFOR","WHILE","WRITETEXT"
                                 };

        private static final int[] DEFINED_STMT_START = new int[]{ALTER, BEGIN, CREATE, DECLARE, DELETE, EXECUTE, EXEC, FETCH, IF, INSERT, PRINT, RETURN, SELECT, UPDATE, USE    };

        private static final int[] TERMINATORS = new int[]{GO, SEMICOLON};
        private static final String[] TERMINATORS_STRING = new String[]{"GO", ";"};

        private static final String[] WATCOM_POST_PARAM= new String[]
                {"BEGIN","RETURNS", "RESULT","AT","WITH", "AS","EXTERNAL","ON","DYNAMIC"};

    /**
	 * Returns the statement terminator array. Different vendors will have their
	 * own terminators defined, so we just leave this method as abstract here.
	 * 
	 * @return statement terminator array
	 */
    public String[] getStatementTerminators()
    {
        return TERMINATORS_STRING;
    }

    public static QuickSQLParser getInstance(){
        return _instance;
    }

    public QuickSQLParser()
    {
        this(new StringReader(""));
    }

    final private void logDebug(String message)
    {
            if (_debug)
                {
                        Activator.getDefault().debug(message);
                }
    }

    final private void logError(String message)
    {
                Activator.getDefault().log(message);
    }

    protected synchronized void initParser(String text)
    {
            _input = text;
        java.io.StringReader sr = new java.io.StringReader( text );
                java.io.Reader r = new java.io.BufferedReader( sr );
                //ReInit will be generated by JavaCC
                ReInit(r);
    }

        public String getInput()
        {
                return _input;
        }

    public boolean match(String input, int pattern)
    {
        try{
        initParser(input);
        switch (pattern)
        {
            case CREATE_PROC_HEADER_PATTERN:
                create_proc_header();
                return true;
            case CREATE_FUNC_HEADER_PATTERN:
                create_func_header();
                return true;
            case CREATE_TRIGGER_HEADER_PATTERN:
                create_trigger_header();
                return true;
            case CREATE_EVENT_HEADER_PATTERN:
                create_event_header();
                return true;
            default:
        }
        }catch(Throwable e)
        {
                logDebug(e.getMessage());
                return false;
        }
        return false;
    }

    public int[] find(String input, String[][] tokens)
    {
        Token[] ts = getTokens(input, tokens);
        if (ts == null)
        {
                return new int[]{-1, -1};
        }

        //calculate index
        int[] index = new int[2];
        index[0] = getStartIndex(ts[0]);
        index[1] = getEndIndex(ts[1]);
        return index;
    }


    public Token[] getTokens(String input, String[][] tokens)
      {
        initParser(input);
            boolean found = true;
            try{
                getNextToken();
                    do
                    {
                            error_skiptobefore1(tokens[0], new String[]{}, false);
                            int i = 0;
                        for (; i< tokens.length; i++)
                        {
                                boolean tokenMatch = false;
                                for (int j=0; j< tokens[i].length; j++)
                                {
                                        if (tokens[i][j].equalsIgnoreCase(getToken(i).image))
                                        {
                                                tokenMatch = true;
                                                break;
                                        }
                                }
                                if (! tokenMatch)
                                {
                                        found = false;
                                        getNextToken();
                                        break;
                                }
                    else
                    {
                        found = true;
                        continue;
                    }
                        }
                        if (token.kind == EOF)
                        {
                                found = false;
                                break;
                        }
                }while(!found);
            }catch(Throwable e)
        {
                logDebug(e.getMessage());
                return null;
        }
        if (! found)
        {
                return null;
        }
        //calculate index
        Token[] ts = new Token[2];
        ts[0] = getToken(0);
        ts[1] = getToken(tokens.length - 1);
        return ts;
    }
    public String[][] getParameters(String input)
    {
        initParser(input);
        try
        {
                return routine_parameters();
        }catch(Throwable e)
        {
                logDebug(e.getMessage());
                return null;
        }
    }

    public String[] getDatatypeInfo(String input)
    {
        initParser(input);
        try
        {
                return datatype_info();
        }catch(Throwable e)
        {
                logDebug(e.getMessage());
                return null;
        }
    }

  final public Token string_literal() throws ParseException {
                                  /*@bgen(jjtree) string_literal */
                                  SimpleNode jjtn000 = new SimpleNode(JJTSTRING_LITERAL);
                                  boolean jjtc000 = true;
                                  jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SINGLE_STRING_LITERAL:
        t = jj_consume_token(SINGLE_STRING_LITERAL);
        break;
      case DOUBLE_STRING_LITERAL:
        t = jj_consume_token(DOUBLE_STRING_LITERAL);
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                 {if (true) return t;}
    } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
    }
    throw new Error("Missing return statement in function");
  }

    /*******************************************************************
     * The SQL grammar starts here
     *******************************************************************/

/***** ROOT SYNTAXS *****/
  final public void any_stmt_token() throws ParseException {
                       /*@bgen(jjtree) any_stmt_token */
  SimpleNode jjtn000 = new SimpleNode(JJTANY_STMT_TOKEN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                error_skiptobefore(new int[]{END, SEMICOLON, GO}, STMT_START);
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public Token id() throws ParseException {
              /*@bgen(jjtree) id */
              SimpleNode jjtn000 = new SimpleNode(JJTID);
              boolean jjtc000 = true;
              jjtree.openNodeScope(jjtn000);Token t = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
      case SQUARE_BRACKET_ID:
      case TEMP_TABLE_NAME:
        t = idplus();
        break;
      case VAR_NAME:
      case GLOBAL_VAR_NAME:
      case QUESTIONMARK:
        t = variable();
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
    {if (true) return t;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public void string() throws ParseException {
                 /*@bgen(jjtree) string */
  SimpleNode jjtn000 = new SimpleNode(JJTSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SINGLE_STRING_LITERAL:
      case DOUBLE_STRING_LITERAL:
        string_literal();
        break;
      case VAR_NAME:
      case GLOBAL_VAR_NAME:
      case QUESTIONMARK:
        variable();
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
                   if (jjtc000) {
                     jjtree.clearNodeScope(jjtn000);
                     jjtc000 = false;
                   } else {
                     jjtree.popNode();
                   }
                   if (jjte000 instanceof RuntimeException) {
                     {if (true) throw (RuntimeException)jjte000;}
                   }
                   if (jjte000 instanceof ParseException) {
                     {if (true) throw (ParseException)jjte000;}
                   }
                   {if (true) throw (Error)jjte000;}
    } finally {
                   if (jjtc000) {
                     jjtree.closeNodeScope(jjtn000, true);
                   }
    }
  }

  final public Token id_string() throws ParseException {
                     /*@bgen(jjtree) id_string */
                     SimpleNode jjtn000 = new SimpleNode(JJTID_STRING);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);Token t = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
      case SQUARE_BRACKET_ID:
      case TEMP_TABLE_NAME:
        t = idplus();
        break;
      case DOUBLE_STRING_LITERAL:
        t = jj_consume_token(DOUBLE_STRING_LITERAL);
        break;
      case VAR_NAME:
      case GLOBAL_VAR_NAME:
      case QUESTIONMARK:
        t = variable();
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
       {if (true) return t;}
    } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             {if (true) throw (RuntimeException)jjte000;}
           }
           if (jjte000 instanceof ParseException) {
             {if (true) throw (ParseException)jjte000;}
           }
           {if (true) throw (Error)jjte000;}
    } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
    }
    throw new Error("Missing return statement in function");
  }

  final public Token id_or_string() throws ParseException {
                        /*@bgen(jjtree) id_or_string */
                        SimpleNode jjtn000 = new SimpleNode(JJTID_OR_STRING);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
      case SQUARE_BRACKET_ID:
      case TEMP_TABLE_NAME:
        t = idplus();
        break;
      case SINGLE_STRING_LITERAL:
      case DOUBLE_STRING_LITERAL:
        t = string_literal();
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
              {if (true) return t;}
    } catch (Throwable jjte000) {
                           if (jjtc000) {
                             jjtree.clearNodeScope(jjtn000);
                             jjtc000 = false;
                           } else {
                             jjtree.popNode();
                           }
                           if (jjte000 instanceof RuntimeException) {
                             {if (true) throw (RuntimeException)jjte000;}
                           }
                           if (jjte000 instanceof ParseException) {
                             {if (true) throw (ParseException)jjte000;}
                           }
                           {if (true) throw (Error)jjte000;}
    } finally {
                           if (jjtc000) {
                             jjtree.closeNodeScope(jjtn000, true);
                           }
    }
    throw new Error("Missing return statement in function");
  }

  final public String prefix() throws ParseException {
                   /*@bgen(jjtree) prefix */
                   SimpleNode jjtn000 = new SimpleNode(JJTPREFIX);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);Token t = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        jj_consume_token(DOT);
        break;
      case SINGLE_STRING_LITERAL:
      case DOUBLE_STRING_LITERAL:
      case ID:
      case SQUARE_BRACKET_ID:
      case TEMP_TABLE_NAME:
        t = id_or_string();
        jj_consume_token(DOT);
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                         {if (true) return t == null?".":t.image + ".";}
    } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            {if (true) throw (RuntimeException)jjte000;}
                          }
                          if (jjte000 instanceof ParseException) {
                            {if (true) throw (ParseException)jjte000;}
                          }
                          {if (true) throw (Error)jjte000;}
    } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                          }
    }
    throw new Error("Missing return statement in function");
  }

  final public String prefix_list() throws ParseException {
                        /*@bgen(jjtree) prefix_list */
                        SimpleNode jjtn000 = new SimpleNode(JJTPREFIX_LIST);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);String retval = "", pre = "";
    try {
      label_1:
      while (true) {
        pre = prefix();
                                                               retval += pre;
        if (jj_2_1(2147483647)) {
          ;
        } else {
          break label_1;
        }
      }
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
             {if (true) return retval;}
    } catch (Throwable jjte000) {
              if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte000 instanceof RuntimeException) {
                {if (true) throw (RuntimeException)jjte000;}
              }
              if (jjte000 instanceof ParseException) {
                {if (true) throw (ParseException)jjte000;}
              }
              {if (true) throw (Error)jjte000;}
    } finally {
              if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
              }
    }
    throw new Error("Missing return statement in function");
  }

//database object such as: table, procedure, view, cursor...
  final public String object() throws ParseException {
                   /*@bgen(jjtree) object */
                   SimpleNode jjtn000 = new SimpleNode(JJTOBJECT);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);String retval = ""; Token t;
    try {
      if (jj_2_2(2147483647)) {
        retval = prefix_list();
      } else {
        ;
      }
      t = id_or_string();
         jjtree.closeNodeScope(jjtn000, true);
         jjtc000 = false;
        {if (true) return retval + t.image;}
    } catch (Throwable jjte000) {
         if (jjtc000) {
           jjtree.clearNodeScope(jjtn000);
           jjtc000 = false;
         } else {
           jjtree.popNode();
         }
         if (jjte000 instanceof RuntimeException) {
           {if (true) throw (RuntimeException)jjte000;}
         }
         if (jjte000 instanceof ParseException) {
           {if (true) throw (ParseException)jjte000;}
         }
         {if (true) throw (Error)jjte000;}
    } finally {
         if (jjtc000) {
           jjtree.closeNodeScope(jjtn000, true);
         }
    }
    throw new Error("Missing return statement in function");
  }

//Special case: "NEW" can be used as id
  final public Token idplus() throws ParseException {
                  /*@bgen(jjtree) idplus */
                  SimpleNode jjtn000 = new SimpleNode(JJTIDPLUS);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        t = jj_consume_token(ID);
        break;
      case TEMP_TABLE_NAME:
        t = jj_consume_token(TEMP_TABLE_NAME);
        break;
      case SQUARE_BRACKET_ID:
        t = jj_consume_token(SQUARE_BRACKET_ID);
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
     {if (true) return t;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

//variable reference
  final public Token variable() throws ParseException {
                    /*@bgen(jjtree) variable */
                    SimpleNode jjtn000 = new SimpleNode(JJTVARIABLE);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VAR_NAME:
        t = jj_consume_token(VAR_NAME);
        break;
      case QUESTIONMARK:
        t = dyn_question_mark();
        break;
      case GLOBAL_VAR_NAME:
        t = jj_consume_token(GLOBAL_VAR_NAME);
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
       jjtree.closeNodeScope(jjtn000, true);
       jjtc000 = false;
      {if (true) return t;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Token dyn_question_mark() throws ParseException {
                             /*@bgen(jjtree) dyn_question_mark */
                             SimpleNode jjtn000 = new SimpleNode(JJTDYN_QUESTION_MARK);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(QUESTIONMARK);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
          {if (true) return t;}
    } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
    }
    throw new Error("Missing return statement in function");
  }

  final public int number() throws ParseException {
                /*@bgen(jjtree) number */
                SimpleNode jjtn000 = new SimpleNode(JJTNUMBER);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);int retval = 0;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MINUS:
        jj_consume_token(MINUS);
        jj_consume_token(INTEGER_LITERAL);
                                try {retval = Integer.parseInt("-" + getToken(0).image);}catch(Exception e){}
        break;
      case INTEGER_LITERAL:
      case PLUS:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
          jj_consume_token(PLUS);
          break;
        default:
          jj_la1[8] = jj_gen;
          ;
        }
        jj_consume_token(INTEGER_LITERAL);
                                    try {retval = Integer.parseInt(getToken(0).image);}catch(Exception e){}
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
         jjtree.closeNodeScope(jjtn000, true);
         jjtc000 = false;
        {if (true) return retval;}
    } finally {
         if (jjtc000) {
           jjtree.closeNodeScope(jjtn000, true);
         }
    }
    throw new Error("Missing return statement in function");
  }

  final public void constant() throws ParseException {
                   /*@bgen(jjtree) constant */
  SimpleNode jjtn000 = new SimpleNode(JJTCONSTANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case MONEY_LITERAL:
        signed_const();
        break;
      case NULL:
      case SINGLE_STRING_LITERAL:
      case DOUBLE_STRING_LITERAL:
      case BINARY_LITERAL:
      case VAR_NAME:
      case GLOBAL_VAR_NAME:
      case QUESTIONMARK:
        unsigned_const();
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
                           if (jjtc000) {
                             jjtree.clearNodeScope(jjtn000);
                             jjtc000 = false;
                           } else {
                             jjtree.popNode();
                           }
                           if (jjte000 instanceof RuntimeException) {
                             {if (true) throw (RuntimeException)jjte000;}
                           }
                           if (jjte000 instanceof ParseException) {
                             {if (true) throw (ParseException)jjte000;}
                           }
                           {if (true) throw (Error)jjte000;}
    } finally {
                           if (jjtc000) {
                             jjtree.closeNodeScope(jjtn000, true);
                           }
    }
  }

  final public Token signed_const() throws ParseException {
                        /*@bgen(jjtree) signed_const */
                        SimpleNode jjtn000 = new SimpleNode(JJTSIGNED_CONST);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
        t = jj_consume_token(INTEGER_LITERAL);
        break;
      case FLOATING_POINT_LITERAL:
        t = jj_consume_token(FLOATING_POINT_LITERAL);
        break;
      case MONEY_LITERAL:
        t = jj_consume_token(MONEY_LITERAL);
        break;
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
              {if (true) return t;}
    } finally {
                           if (jjtc000) {
                             jjtree.closeNodeScope(jjtn000, true);
                           }
    }
    throw new Error("Missing return statement in function");
  }

  final public Token unsigned_const() throws ParseException {
                          /*@bgen(jjtree) unsigned_const */
                          SimpleNode jjtn000 = new SimpleNode(JJTUNSIGNED_CONST);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BINARY_LITERAL:
        t = jj_consume_token(BINARY_LITERAL);
        break;
      case SINGLE_STRING_LITERAL:
      case DOUBLE_STRING_LITERAL:
        t = string_literal();
        break;
      case NULL:
        t = null_stmt();
        break;
      case VAR_NAME:
      case GLOBAL_VAR_NAME:
      case QUESTIONMARK:
        t = variable();
        break;
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                {if (true) return t;}
    } catch (Throwable jjte000) {
                            if (jjtc000) {
                              jjtree.clearNodeScope(jjtn000);
                              jjtc000 = false;
                            } else {
                              jjtree.popNode();
                            }
                            if (jjte000 instanceof RuntimeException) {
                              {if (true) throw (RuntimeException)jjte000;}
                            }
                            if (jjte000 instanceof ParseException) {
                              {if (true) throw (ParseException)jjte000;}
                            }
                            {if (true) throw (Error)jjte000;}
    } finally {
                            if (jjtc000) {
                              jjtree.closeNodeScope(jjtn000, true);
                            }
    }
    throw new Error("Missing return statement in function");
  }

  final public String literal() throws ParseException {
                    /*@bgen(jjtree) literal */
                    SimpleNode jjtn000 = new SimpleNode(JJTLITERAL);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);Token t; boolean negative = false;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case MONEY_LITERAL:
      case PLUS:
      case MINUS:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
        case MINUS:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case PLUS:
            jj_consume_token(PLUS);
            break;
          case MINUS:
            jj_consume_token(MINUS);
                        negative = true;
            break;
          default:
            jj_la1[13] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[14] = jj_gen;
          ;
        }
        t = signed_const();
        break;
      case NULL:
      case SINGLE_STRING_LITERAL:
      case DOUBLE_STRING_LITERAL:
      case BINARY_LITERAL:
      case VAR_NAME:
      case GLOBAL_VAR_NAME:
      case QUESTIONMARK:
        t = unsigned_const();
        break;
      case ID:
      case SQUARE_BRACKET_ID:
      case TEMP_TABLE_NAME:
        t = idplus();
        break;
      case PRIMARY:
        t = jj_consume_token(PRIMARY);
        break;
      case FOREIGN:
        t = jj_consume_token(FOREIGN);
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
          {if (true) return negative?"-"+t.image:t.image;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Token null_stmt() throws ParseException {
                     /*@bgen(jjtree) null_stmt */
                     SimpleNode jjtn000 = new SimpleNode(JJTNULL_STMT);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(NULL);
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                          {if (true) return t;}
    } finally {
                           if (jjtc000) {
                             jjtree.closeNodeScope(jjtn000, true);
                           }
    }
    throw new Error("Missing return statement in function");
  }

  final public String length_spec() throws ParseException {
                        /*@bgen(jjtree) length_spec */
                        SimpleNode jjtn000 = new SimpleNode(JJTLENGTH_SPEC);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);String retval = ""; int n = 0;
    try {
      if (jj_2_3(2)) {
        jj_consume_token(OPENPAREN);
        n = number();
                                                 retval = "(" + n;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          jj_consume_token(COMMA);
          n = number();
                                                                                        retval += "," + n;
          break;
        default:
          jj_la1[16] = jj_gen;
          ;
        }
        jj_consume_token(CLOSEPAREN);
                                                                                                                   retval += ")";
      } else {
        ;
      }
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                 {if (true) return retval;}
    } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte000;}
                  }
                  if (jjte000 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte000;}
                  }
                  {if (true) throw (Error)jjte000;}
    } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
    }
    throw new Error("Missing return statement in function");
  }

  final public String datatype() throws ParseException {
                   /*@bgen(jjtree) datatype */
                   SimpleNode jjtn000 = new SimpleNode(JJTDATATYPE);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);String retval = ""; Token t; String l="";
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        label_2:
        while (true) {
          t = jj_consume_token(ID);
                    if (retval.equals("")) retval += t.image; else retval += " " + t.image;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ID:
            ;
            break;
          default:
            jj_la1[17] = jj_gen;
            break label_2;
          }
        }
        break;
      case SQUARE_BRACKET_ID:
        t = jj_consume_token(SQUARE_BRACKET_ID);
                                                                                                                          retval += t.image;
        break;
      case DOUBLE_STRING_LITERAL:
        t = jj_consume_token(DOUBLE_STRING_LITERAL);
                                                                                                                                                                             retval += t.image;
        break;
      default:
        jj_la1[18] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      l = length_spec();
                                                                                                                                                                                                                     retval += l;
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         {if (true) return retval;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public String[] datatype_info() throws ParseException {
                          /*@bgen(jjtree) datatype_info */
                          SimpleNode jjtn000 = new SimpleNode(JJTDATATYPE_INFO);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);String name = null; Token t; String precision= null; String scale = null; int n = 0;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        label_3:
        while (true) {
          t = jj_consume_token(ID);
                    if (name == null) name = t.image; else name += " " + t.image;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ID:
            ;
            break;
          default:
            jj_la1[19] = jj_gen;
            break label_3;
          }
        }
        break;
      case SQUARE_BRACKET_ID:
        t = jj_consume_token(SQUARE_BRACKET_ID);
                                                                                                                name = t.image;
        break;
      case DOUBLE_STRING_LITERAL:
        t = jj_consume_token(DOUBLE_STRING_LITERAL);
                                                                                                                                                                 name = t.image;
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      if (jj_2_4(2)) {
        jj_consume_token(OPENPAREN);
        n = number();
                                         precision = "" + n;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          jj_consume_token(COMMA);
          n = number();
                                                                                  scale = "" + n;
          break;
        default:
          jj_la1[21] = jj_gen;
          ;
        }
        jj_consume_token(CLOSEPAREN);
      } else {
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        if (scale != null)
        {
                {if (true) return new String[]{name, precision, scale};}
        }
        else if (precision != null)
        {
                {if (true) return new String[]{name, precision};}
        }
        else
        {
                {if (true) return new String[]{name};}
        }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/**
* @return name: defaultValue
*/
  final public String[] parameter() throws ParseException {
                       /*@bgen(jjtree) parameter */
                       SimpleNode jjtn000 = new SimpleNode(JJTPARAMETER);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);Token name=null; String defaultValue=null; String type=null; int direction = 0;
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VAR_NAME:
          name = jj_consume_token(VAR_NAME);
          type = datatype();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EQUAL:
            jj_consume_token(EQUAL);
            defaultValue = procparmdefault();
            break;
          default:
            jj_la1[22] = jj_gen;
            ;
          }
          direction = param_options();
          break;
        case IN:
        case INOUT:
        case OUT:
        case DOUBLE_STRING_LITERAL:
        case ID:
        case SQUARE_BRACKET_ID:
        case GLOBAL_VAR_NAME:
        case TEMP_TABLE_NAME:
        case QUESTIONMARK:
                             direction = 0;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IN:
          case INOUT:
          case OUT:
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case IN:
              jj_consume_token(IN);
              break;
            case OUT:
                                                       direction = 1;
              jj_consume_token(OUT);
              break;
            case INOUT:
                                                                                 direction = 2;
              jj_consume_token(INOUT);
              break;
            default:
              jj_la1[23] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
          default:
            jj_la1[24] = jj_gen;
            ;
          }
          name = id_string();
          type = datatype();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DEFAULT_VAL:
            jj_consume_token(DEFAULT_VAL);
            defaultValue = procparmdefault();
            break;
          default:
            jj_la1[25] = jj_gen;
            ;
          }
          break;
        case SQLSTATE:
          name = jj_consume_token(SQLSTATE);
          break;
        case SQLCODE:
          name = jj_consume_token(SQLCODE);
          break;
        default:
          jj_la1[26] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
            error_skiptobefore(new int[]{}, new int[]{COMMA, CLOSEPAREN, WITH, AS, BEGIN});
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         String[] param = new String[2];
         param[0] = name.toString();
         param[1] = defaultValue;
         {if (true) return param;}
    } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte000;}
                  }
                  if (jjte000 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte000;}
                  }
                  {if (true) throw (Error)jjte000;}
    } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
    }
    throw new Error("Missing return statement in function");
  }

  final public String optional_param_default() throws ParseException {
                                   /*@bgen(jjtree) optional_param_default */
                                   SimpleNode jjtn000 = new SimpleNode(JJTOPTIONAL_PARAM_DEFAULT);
                                   boolean jjtc000 = true;
                                   jjtree.openNodeScope(jjtn000);String t = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
        jj_consume_token(EQUAL);
        t = literal();
        break;
      default:
        jj_la1[27] = jj_gen;
        ;
      }
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                         {if (true) return t;}
    } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            {if (true) throw (RuntimeException)jjte000;}
                          }
                          if (jjte000 instanceof ParseException) {
                            {if (true) throw (ParseException)jjte000;}
                          }
                          {if (true) throw (Error)jjte000;}
    } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                          }
    }
    throw new Error("Missing return statement in function");
  }

  final public int param_options() throws ParseException {
                       /*@bgen(jjtree) param_options */
                       SimpleNode jjtn000 = new SimpleNode(JJTPARAM_OPTIONS);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);int direction = 0;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IN:
      case OUT:
      case OUTPUT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IN:
          jj_consume_token(IN);
          break;
        case OUT:
        case OUTPUT:
          out_option();
                              direction = 1;
          break;
        default:
          jj_la1[28] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[29] = jj_gen;
        ;
      }
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
             {if (true) return direction;}
    } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            {if (true) throw (RuntimeException)jjte000;}
                          }
                          if (jjte000 instanceof ParseException) {
                            {if (true) throw (ParseException)jjte000;}
                          }
                          {if (true) throw (Error)jjte000;}
    } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                          }
    }
    throw new Error("Missing return statement in function");
  }

  final public void out_option() throws ParseException {
                     /*@bgen(jjtree) out_option */
  SimpleNode jjtn000 = new SimpleNode(JJTOUT_OPTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OUT:
        jj_consume_token(OUT);
        break;
      case OUTPUT:
        jj_consume_token(OUTPUT);
        break;
      default:
        jj_la1[30] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
                           if (jjtc000) {
                             jjtree.closeNodeScope(jjtn000, true);
                           }
    }
  }

  final public void any_chars() throws ParseException {
                  /*@bgen(jjtree) any_chars */
  SimpleNode jjtn000 = new SimpleNode(JJTANY_CHARS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         token_source.SwitchTo(IGNORE_STATE);
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void create_proc_header() throws ParseException {
                           /*@bgen(jjtree) create_proc_header */
  SimpleNode jjtn000 = new SimpleNode(JJTCREATE_PROC_HEADER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(CREATE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PROC:
        jj_consume_token(PROC);
        break;
      case PROCEDURE:
        jj_consume_token(PROCEDURE);
        break;
      default:
        jj_la1[31] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      any_chars();
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void create_func_header() throws ParseException {
                           /*@bgen(jjtree) create_func_header */
  SimpleNode jjtn000 = new SimpleNode(JJTCREATE_FUNC_HEADER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(CREATE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FUNC:
        jj_consume_token(FUNC);
        break;
      case FUNCTION:
        jj_consume_token(FUNCTION);
        break;
      default:
        jj_la1[32] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      any_chars();
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void create_trigger_header() throws ParseException {
                              /*@bgen(jjtree) create_trigger_header */
  SimpleNode jjtn000 = new SimpleNode(JJTCREATE_TRIGGER_HEADER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(CREATE);
      jj_consume_token(TRIGGER);
      any_chars();
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void create_event_header() throws ParseException {
                            /*@bgen(jjtree) create_event_header */
  SimpleNode jjtn000 = new SimpleNode(JJTCREATE_EVENT_HEADER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(CREATE);
      jj_consume_token(EVENT);
      any_chars();
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public String[][] parameters() throws ParseException {
                         /*@bgen(jjtree) parameters */
                         SimpleNode jjtn000 = new SimpleNode(JJTPARAMETERS);
                         boolean jjtc000 = true;
                         jjtree.openNodeScope(jjtn000);ArrayList params = new ArrayList(); String[] param = new String[2];
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IN:
      case INOUT:
      case OUT:
      case SQLCODE:
      case SQLSTATE:
      case DOUBLE_STRING_LITERAL:
      case ID:
      case SQUARE_BRACKET_ID:
      case VAR_NAME:
      case GLOBAL_VAR_NAME:
      case TEMP_TABLE_NAME:
      case OPENPAREN:
      case QUESTIONMARK:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPENPAREN:
          jj_consume_token(OPENPAREN);
          break;
        default:
          jj_la1[33] = jj_gen;
          ;
        }
        param = parameter();
                                     params.add(param);
        label_4:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[34] = jj_gen;
            break label_4;
          }
          jj_consume_token(COMMA);
          param = parameter();
                                                                                        params.add(param);
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CLOSEPAREN:
          jj_consume_token(CLOSEPAREN);
          break;
        default:
          jj_la1[35] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[36] = jj_gen;
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         {if (true) return (String[][])params.toArray(new String[params.size()][2]);}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public String[][] routine_parameters() throws ParseException {
                                 /*@bgen(jjtree) routine_parameters */
                                 SimpleNode jjtn000 = new SimpleNode(JJTROUTINE_PARAMETERS);
                                 boolean jjtc000 = true;
                                 jjtree.openNodeScope(jjtn000);String[][] params = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CREATE:
        jj_consume_token(CREATE);
        break;
      case ALTER:
        jj_consume_token(ALTER);
        break;
      default:
        jj_la1[37] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PROC:
        jj_consume_token(PROC);
        break;
      case PROCEDURE:
        jj_consume_token(PROCEDURE);
        break;
      case FUNC:
        jj_consume_token(FUNC);
        break;
      case FUNCTION:
        jj_consume_token(FUNCTION);
        break;
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      object();
      params = parameters();
      any_chars();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         {if (true) return params;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

//might contain expressions
  final public String procparmdefault() throws ParseException {
                            /*@bgen(jjtree) procparmdefault */
  SimpleNode jjtn000 = new SimpleNode(JJTPROCPARMDEFAULT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        Token start = getToken(1);//next token
        int startIndex = getStartIndex(start);
        boolean match = false;
        do{
        int balance = 0;//open parenthesis minus close parenthesis
        error_skiptobefore(new int[]{OPENPAREN}, new int[]{COMMA, CLOSEPAREN, OUTPUT, OUT, IN, WITH, AS});

        if (getToken(0).kind == OPENPAREN )
        {
                balance ++;
        }

        if (getToken(1).kind == CLOSEPAREN )
        {
                balance --;
        }
        Token end = getToken(1);
        Token next = getToken(2);
        if (end == null || next == null)
        {
                match = true;
                break;
        }
        else if (end.kind == EOF || end.kind == COMMA)
        {
                match = true;
                break;
        }
        else if (end.kind == COMMA && balance == 0)
        {
                match = true;
                break;
        }
        else if (end.kind == WITH && balance == 0)
        {
                match = true;
                break;
        }
        else if (end.kind == AS && balance == 0)//TSQL
        {
                match = true;
                break;
        }
        else if (end.kind == OUTPUT || end.kind == OUT || end.kind == IN )//TSQL: IN/OUT follows the default value
        {
                match = true;
                break;
        }
        else if (end.kind == CLOSEPAREN && balance < 0)
        {
                for (int i=0;i<WATCOM_POST_PARAM.length; i++)
                {
                        if (WATCOM_POST_PARAM[i].equalsIgnoreCase(next.image))
                        {
                                match = true;
                                break;
                        }
                }
        }

        }while (!match);
        int endIndex = getEndIndex(getToken(0));
        if (endIndex > startIndex)
        {
                {if (true) return _input.substring(startIndex, endIndex);}
        }
        else
        {
                {if (true) return null;}
        }
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  void error_skiptobefore(int[] tokinds, int[] beforekinds) throws ParseException {
                                                           /*@bgen(jjtree) error_skiptobefore */
SimpleNode jjtn000 = new SimpleNode(JJTERROR_SKIPTOBEFORE);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
try {boolean match = false;
  Token t1 = getToken(0);
    // The following loop consumes tokens all the way up to a token of
    // "kind".  We use a do-while loop rather than a while because the
    // current token is the one immediately before the erroneous token
    // (in our case the token immediately before what should have been
    // "if"/"while".
  do {
    match = token.kind == 0 || getToken(1).kind == 0 ; // 0 means the <EOF>
    if (match) {break;}
    for (int i=0; i< tokinds.length; i++){
        match = match || token.kind == tokinds[i];
        if (match) {break;}
    }
    if (match) {break;}
    for (int i=0; i< beforekinds.length; i++){
        match = match || getToken(1).kind == beforekinds[i];
        if (match) {break;}
    }
    if (!match){
        logDebug("current token:" + token.image);
        getNextToken();
    }

  } while (!match);

  Token t2 = getToken(0);
  if (t1 == t2 ){
        //force get next token
        logDebug("current token:" + token.image);
        //System.out.println("current token:" + token.image);
    getNextToken();
  }/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
  }

  void error_skiptobefore1(String[] tokinds, String[] beforekinds, boolean force) throws ParseException {
                                                                                 /*@bgen(jjtree) error_skiptobefore1 */
SimpleNode jjtn000 = new SimpleNode(JJTERROR_SKIPTOBEFORE1);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
try {boolean match = false;
  Token t1 = getToken(0);
    // The following loop consumes tokens all the way up to a token of
    // "kind".  We use a do-while loop rather than a while because the
    // current token is the one immediately before the erroneous token
    // (in our case the token immediately before what should have been
    // "if"/"while".
  do {
    match = token.kind == 0 || getToken(1).kind == 0 ; // 0 means the <EOF>
    if (match) {break;}
    for (int i=0; i< tokinds.length; i++){
        match = match || tokinds[i].equalsIgnoreCase(token.image);
        if (match) {break;}
    }
    if (match) {break;}
    for (int i=0; i< beforekinds.length; i++){
        match = match || beforekinds[i].equalsIgnoreCase(getToken(1).image);
        if (match) {break;}
    }
    if (!match){
        logDebug("current token:" + token.image);
        getNextToken();
    }

  } while (!match);

  Token t2 = getToken(0);
  if (t1 == t2 && force ){
        //force get next token
        logDebug("current token:" + token.image);
        //System.out.println("current token:" + token.image);
    getNextToken();
  }/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  final private boolean jj_3R_13() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(209)) {
    jj_scanpos = xsp;
    if (jj_scan_token(215)) {
    jj_scanpos = xsp;
    if (jj_scan_token(210)) return true;
    }
    }
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_scan_token(OPENPAREN)) return true;
    if (jj_3R_7()) return true;
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_scan_token(OPENPAREN)) return true;
    if (jj_3R_7()) return true;
    return false;
  }

  final private boolean jj_3R_11() {
    if (jj_3R_13()) return true;
    return false;
  }

  final private boolean jj_3R_8() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_11()) {
    jj_scanpos = xsp;
    if (jj_3R_12()) return true;
    }
    return false;
  }

  final private boolean jj_3R_14() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(204)) {
    jj_scanpos = xsp;
    if (jj_scan_token(205)) return true;
    }
    return false;
  }

  final private boolean jj_3R_6() {
    if (jj_3R_8()) return true;
    return false;
  }

  final private boolean jj_3_2() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_6()) jj_scanpos = xsp;
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  final private boolean jj_3R_10() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(236)) jj_scanpos = xsp;
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_9() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  final private boolean jj_3R_5() {
    if (jj_3R_8()) return true;
    return false;
  }

  final private boolean jj_3_1() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_5()) jj_scanpos = xsp;
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  final private boolean jj_3R_12() {
    if (jj_3R_14()) return true;
    return false;
  }

  final private boolean jj_3R_7() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_9()) {
    jj_scanpos = xsp;
    if (jj_3R_10()) return true;
    }
    return false;
  }

  public QuickSQLParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[39];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static private int[] jj_la1_5;
  static private int[] jj_la1_6;
  static private int[] jj_la1_7;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
      jj_la1_3();
      jj_la1_4();
      jj_la1_5();
      jj_la1_6();
      jj_la1_7();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x0,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5000000,0x5000000,0x0,0x5000000,0x0,0x1000000,0x1000000,0x0,0x0,0xc000,0x0,0x0,0x0,0x5000000,0x0,0xc000,};
   }
   private static void jj_la1_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x8000,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x10000000,0x0,0x10000000,0x0,0x30000000,0x30000000,0x30000000,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,};
   }
   private static void jj_la1_4() {
      jj_la1_4 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x180,0x0,0x0,0x0,0x0,0x0,0x0,0x180,};
   }
   private static void jj_la1_5() {
      jj_la1_5 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_6() {
      jj_la1_6 = new int[] {0x3000,0xd60000,0x503000,0xd62000,0x863000,0x40863000,0x860000,0x500000,0x0,0x200,0x517600,0x10600,0x507000,0x0,0x0,0xd77600,0x10000000,0x20000,0x62000,0x20000,0x62000,0x10000000,0x0,0x0,0x0,0x0,0xd62030,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0xd62030,0x0,0x0,};
   }
   private static void jj_la1_7() {
      jj_la1_7 = new int[] {0x0,0x4000,0x4000,0x4000,0x0,0x0,0x0,0x4000,0x1000,0x3000,0x4000,0x0,0x4000,0x3000,0x3000,0x7000,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x4000,0x20,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x200,0x4100,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[4];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public QuickSQLParser(java.io.InputStream stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new QuickSQLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 39; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 39; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public QuickSQLParser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new QuickSQLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 39; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 39; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public QuickSQLParser(QuickSQLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 39; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(QuickSQLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 39; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[242];
    for (int i = 0; i < 242; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 39; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
          if ((jj_la1_5[i] & (1<<j)) != 0) {
            la1tokens[160+j] = true;
          }
          if ((jj_la1_6[i] & (1<<j)) != 0) {
            la1tokens[192+j] = true;
          }
          if ((jj_la1_7[i] & (1<<j)) != 0) {
            la1tokens[224+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 242; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 4; i++) {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
